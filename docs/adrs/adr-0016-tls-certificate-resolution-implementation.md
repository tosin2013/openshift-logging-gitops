# ADR-0016: TLS Certificate Resolution Implementation

## Status
Accepted

## Date
2025-08-17

## Last Updated
2025-08-17 - Incorporated comprehensive research findings on OpenShift Logging 6.3 TLS configuration

## Context

ADR-0010 documented the TLS certificate management strategy, but implementation is incomplete. Vector collectors continue to fail TLS verification when connecting to Loki Gateway, preventing log delivery despite successful log collection.

### Current TLS Failure Evidence
```
Vector Error: error:0A000086:SSL routines:tls_post_process_server_certificate:certificate verify failed:ssl/statem/statem_clnt.c:2102:: self-signed certificate in certificate chain

Loki Gateway Certificate:
Issuer: CN=openshift-service-serving-signer@1755265534
Subject: CN=logging-loki-gateway-http.openshift-logging.svc
```

### Implementation Gap Analysis
- ✅ **ADR-0010 Strategy**: TLS certificate management documented
- ✅ **CA Bundle Available**: `openshift-service-ca.crt` ConfigMap exists
- ✅ **ClusterLogForwarder Valid**: Configuration passes validation
- ❌ **TLS Configuration Missing**: No CA bundle reference in ClusterLogForwarder
- ❌ **Vector Still Failing**: Certificate verification errors persist

### Root Cause Analysis (Updated with Research Findings)
Based on comprehensive research into OpenShift Logging 6.3 and Vector TLS mechanisms:

1. **Secret Data Key Format Issue**: ClusterLogForwarder requires `ca-bundle.crt` data key in secrets, not `ca.crt` as generated by Cert Manager
2. **Certificate Chain Validation**: Vector requires the Root CA certificate in its trust bundle, not intermediate or server certificates
3. **API Version Dependency**: OpenShift Logging 6.3 exclusively uses `observability.openshift.io/v1` - legacy versions are ignored
4. **Vector OpenSSL Integration**: Vector uses embedded OpenSSL that loads CA bundles from specific mounted file paths
5. **Configuration Application Gap**: TLS configuration added to overlays but not properly applied to Vector pods due to strategic merge patching issues

## Decision

We will implement a **dual-option TLS certificate resolution strategy** that provides both immediate resolution and long-term sustainable certificate management. This approach allows teams to choose between rapid deployment and comprehensive security based on their environment and timeline constraints.

### Strategic Approach: Two-Path Implementation

**Option A: Immediate Resolution** - TLS verification bypass for rapid log delivery restoration
**Option B: Comprehensive Security** - Full certificate validation with Cert Manager integration

Both options address OpenShift Logging 6.3 requirements while providing different trade-offs between implementation speed and security posture.

### Implementation Approach

#### Option A: Immediate Resolution - TLS Verification Bypass (Emergency/Development)
**Use Case**: Immediate log delivery restoration, development environments, emergency situations
**Timeline**: 15 minutes implementation
**Security Level**: Reduced (encrypted but not verified)

```yaml
# OPTION A: Quick resolution with TLS bypass
apiVersion: observability.openshift.io/v1
kind: ClusterLogForwarder
metadata:
  name: instance
  namespace: openshift-logging
  annotations:
    # Document this is temporary for tracking
    logging.openshift.io/tls-bypass: "temporary-emergency-fix"
    logging.openshift.io/bypass-reason: "certificate-verification-blocking-logs"
    logging.openshift.io/target-migration: "option-b-cert-manager"
spec:
  outputs:
  - name: default-lokistack
    type: lokiStack
    lokiStack:
      target:
        name: logging-loki
        namespace: openshift-logging
      authentication:
        token:
          from: serviceAccount
      tls:
        insecureSkipVerify: true  # TEMPORARY: Skip certificate verification
```

**Pros**: ✅ Immediate log delivery, ✅ Simple implementation, ✅ No dependencies
**Cons**: ❌ Reduced security, ❌ Not production-ready, ❌ Manual migration needed

#### Option B: Comprehensive Security - Full Certificate Validation (Production)
**Use Case**: Production environments, long-term sustainable solution, security compliance
**Timeline**: 2-4 hours implementation
**Security Level**: Full (encrypted and verified with automated lifecycle)

Based on research findings, implement a comprehensive solution using Cert Manager for certificate lifecycle management:

```yaml
# Create dedicated secret with proper ca-bundle.crt key
apiVersion: v1
kind: Secret
metadata:
  name: clf-trust-bundle
  namespace: openshift-logging
type: Opaque
data:
  # Root CA certificate from Cert Manager internal-root-ca-secret
  ca-bundle.crt: <base64-encoded-root-ca-cert>
---
# ClusterLogForwarder with correct secret reference
apiVersion: observability.openshift.io/v1
kind: ClusterLogForwarder
metadata:
  name: instance
  namespace: openshift-logging
spec:
  outputs:
  - name: default-lokistack
    type: lokiStack
    lokiStack:
      target:
        name: logging-loki
        namespace: openshift-logging
      authentication:
        token:
          from: serviceAccount
      tls:
        caCert:
          secretName: clf-trust-bundle
          key: ca-bundle.crt
```

**Pros**: ✅ Full security, ✅ Automated lifecycle, ✅ Scalable, ✅ Production-ready
**Cons**: ❌ Complex setup, ❌ Multiple dependencies, ❌ Longer implementation time

### Decision Matrix: When to Use Each Option

| Criteria | Option A (TLS Bypass) | Option B (Full Validation) |
|----------|----------------------|----------------------------|
| **Environment** | Development, Staging | Production, Security-Critical |
| **Timeline** | Immediate (< 1 hour) | Planned (2-4 hours) |
| **Security Requirements** | Moderate | High |
| **Compliance** | Internal only | External audit ready |
| **Team Expertise** | Basic | Advanced |
| **Maintenance** | Manual migration needed | Automated |
| **Risk Tolerance** | Higher | Lower |

### Migration Path: A → B

Teams can start with Option A for immediate resolution and migrate to Option B:

```bash
# Phase 1: Deploy Option A (immediate)
# Phase 2: Implement Option B infrastructure (parallel)
# Phase 3: Switch from A to B (planned maintenance)
# Phase 4: Remove Option A configuration
```

### Technical Implementation

## Option A Implementation: TLS Verification Bypass

### Quick Start (15 minutes)

#### Step A1: Deploy Immediate Fix
```bash
# Apply TLS bypass configuration
cat <<EOF | oc apply -f -
apiVersion: observability.openshift.io/v1
kind: ClusterLogForwarder
metadata:
  name: instance
  namespace: openshift-logging
  annotations:
    logging.openshift.io/tls-bypass: "temporary-emergency-fix"
    logging.openshift.io/implementation-date: "$(date -Iseconds)"
    logging.openshift.io/target-migration: "option-b-cert-manager"
spec:
  outputs:
  - name: default-lokistack
    type: lokiStack
    lokiStack:
      target:
        name: logging-loki
        namespace: openshift-logging
      authentication:
        token:
          from: serviceAccount
      tls:
        insecureSkipVerify: true
  pipelines:
  - name: forward-app-logs-to-loki
    inputRefs:
    - application
    outputRefs:
    - default-lokistack
EOF
```

#### Step A2: Validate Immediate Resolution
```bash
# Check Vector logs for successful delivery
oc logs -f -l app.kubernetes.io/name=vector -n openshift-logging | grep -E "successfully sent|delivered"

# Verify no TLS errors (should be none with bypass)
oc logs -l app.kubernetes.io/name=vector -n openshift-logging --since=2m | grep "certificate verify failed" || echo "✅ No TLS errors"
```

#### Step A3: Plan Migration to Option B
```bash
# Create migration tracking issue
echo "TODO: Migrate from Option A to Option B within 30 days" >> TODO.md
echo "- [ ] Implement Cert Manager PKI (Option B)" >> TODO.md
echo "- [ ] Test Option B in parallel" >> TODO.md
echo "- [ ] Switch production traffic to Option B" >> TODO.md
echo "- [ ] Remove Option A configuration" >> TODO.md
```

## Option B Implementation: Full Certificate Validation

### Comprehensive Setup (2-4 hours)

#### Step B1: Establish Internal PKI with Cert Manager
```yaml
# Create self-signed ClusterIssuer for internal PKI
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: selfsigned-ca-issuer
spec:
  selfSigned: {}
---
# Create Root CA certificate
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: internal-root-ca
  namespace: cert-manager
spec:
  isCA: true
  commonName: internal-root-ca
  secretName: internal-root-ca-secret
  privateKey:
    algorithm: ECDSA
    size: 256
  issuerRef:
    name: selfsigned-ca-issuer
    kind: ClusterIssuer
---
# Create CA ClusterIssuer for signing service certificates
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: internal-ca-issuer
spec:
  ca:
    secretName: internal-root-ca-secret
```

#### Step B2: Create Loki Gateway Certificate
```yaml
# Certificate for Loki Gateway service
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: lokistack-gateway-tls
  namespace: openshift-logging
spec:
  secretName: lokistack-gateway-tls-secret
  duration: 2160h # 90d
  renewBefore: 360h # 15d
  issuerRef:
    name: internal-ca-issuer
    kind: ClusterIssuer
  dnsNames:
    - logging-loki-gateway-http.openshift-logging.svc
    - logging-loki-gateway-http.openshift-logging.svc.cluster.local
```

#### Step B3: Create Dedicated Secret for ClusterLogForwarder
```bash
# Extract Root CA and create proper secret for ClusterLogForwarder
oc get secret internal-root-ca-secret -n cert-manager -o jsonpath='{.data.tls\.crt}' | base64 -d > internal-root-ca.pem

oc create secret generic clf-trust-bundle -n openshift-logging \
  --from-file=ca-bundle.crt=internal-root-ca.pem
```

#### Step B4: Update ClusterLogForwarder Template
```yaml
# base/cluster-log-forwarder/cluster-log-forwarder-template.yaml
apiVersion: observability.openshift.io/v1  # CRITICAL: Use correct API version
kind: ClusterLogForwarder
metadata:
  name: instance
  namespace: openshift-logging
spec:
  outputs:
  - name: default-lokistack
    type: lokiStack
    lokiStack:
      target:
        name: logging-loki
        namespace: openshift-logging
      authentication:
        token:
          from: serviceAccount
      tls:
        caCert:
          secretName: clf-trust-bundle  # Reference dedicated secret
          key: ca-bundle.crt           # Use correct key name
```

#### Step B5: Configure ArgoCD ignoreDifferences
```yaml
# Handle Cert Manager dynamic secret updates
spec:
  ignoreDifferences:
  - group: ""
    kind: Secret
    name: lokistack-gateway-tls-secret
    namespace: openshift-logging
    jsonPointers:
    - /data
  - group: cert-manager.io
    kind: Certificate
    jsonPointers:
    - /status
```

#### Step B6: Validation Commands
```bash
# Verify FIPS compatibility (research finding)
oc get nodes -o jsonpath='{.items[*].status.nodeInfo.osImage}' | grep -i fips

# Test configuration with dry run
kustomize build overlays/dev | oc apply --dry-run=server -f -

# Monitor Vector logs for TLS resolution
oc logs -f -l app.kubernetes.io/name=vector -n openshift-logging | grep -E "TLS|certificate|error"
```

### Migration Strategy: Option A → Option B

For teams implementing Option A first and migrating to Option B:

#### Phase 1: Immediate Resolution (Option A)
```bash
# Deploy Option A for immediate log delivery
oc apply -f option-a-tls-bypass.yaml

# Validate log delivery working
oc logs -l app.kubernetes.io/name=vector -n openshift-logging | grep "successfully sent"
```

#### Phase 2: Parallel Implementation (Option B)
```bash
# Implement Cert Manager PKI (parallel to Option A)
oc apply -f cert-manager-pki.yaml

# Create certificates and secrets
oc apply -f loki-gateway-certificate.yaml
./create-clf-trust-bundle.sh

# Test Option B configuration (dry-run)
oc apply --dry-run=server -f option-b-full-validation.yaml
```

#### Phase 3: Cutover (A → B)
```bash
# Switch to Option B during maintenance window
oc apply -f option-b-full-validation.yaml

# Validate TLS verification working
oc logs -l app.kubernetes.io/name=vector -n openshift-logging | grep -v "certificate verify failed"

# Remove Option A annotations
oc annotate clusterlogforwarder instance -n openshift-logging \
  logging.openshift.io/tls-bypass- \
  logging.openshift.io/bypass-reason- \
  logging.openshift.io/target-migration-
```

#### Phase 4: Cleanup
```bash
# Document successful migration
echo "✅ Migrated from Option A to Option B on $(date)" >> MIGRATION_LOG.md

# Remove temporary configurations
# (Option A configuration already replaced by Option B)
```

## Consequences

### Option A Consequences (TLS Bypass)

#### Positive
- ✅ **Immediate Resolution**: Log delivery restored in 15 minutes
- ✅ **Simple Implementation**: Single configuration change
- ✅ **No Dependencies**: Works without additional infrastructure
- ✅ **Emergency Ready**: Perfect for urgent log delivery restoration

#### Negative
- ❌ **Reduced Security**: TLS encryption without certificate verification
- ❌ **Compliance Risk**: May not meet security audit requirements
- ❌ **Technical Debt**: Requires planned migration to production solution
- ❌ **Manual Tracking**: Need to track and plan migration

### Option B Consequences (Full Validation)
#### Positive
- ✅ **Production Security**: Full TLS certificate verification
- ✅ **Automated Lifecycle**: Cert Manager handles certificate renewal
- ✅ **Compliance Ready**: Meets security audit requirements
- ✅ **Scalable PKI**: Internal PKI can be extended to other services
- ✅ **GitOps Compatible**: Certificate management integrated with ArgoCD workflow
- ✅ **Monitoring Ready**: Cert Manager provides Prometheus metrics for certificate health
- ✅ **Long-term Sustainable**: No manual certificate management required

#### Negative
- ❌ **Implementation Complexity**: Multi-step setup with PKI, certificates, and secrets
- ❌ **Additional Dependencies**: Requires Cert Manager operator and configuration
- ❌ **Longer Timeline**: 2-4 hours implementation vs 15 minutes for Option A
- ❌ **Certificate Chain Management**: Need to understand Root CA vs service certificate distinction
- ❌ **ArgoCD Configuration**: Requires ignoreDifferences for operator-managed resources
- ❌ **FIPS Compatibility Risk**: Vector may not work in FIPS-enabled clusters

### Combined Strategy Benefits
- ✅ **Flexible Implementation**: Choose approach based on urgency and requirements
- ✅ **Risk Mitigation**: Option A provides immediate relief while Option B is implemented
- ✅ **Team Alignment**: Different teams can use different options based on expertise
- ✅ **Migration Path**: Clear progression from quick fix to production solution

### Risks Mitigated
- **Log Loss**: Prevents loss of logs due to delivery failures
- **Security Gaps**: Maintains TLS encryption without verification bypass
- **Operational Issues**: Resolves persistent Vector retry loops
- **Certificate Expiry**: Automated renewal prevents service disruption
- **Configuration Drift**: GitOps management ensures consistent certificate configuration
- **Manual Certificate Management**: Eliminates error-prone manual certificate processes

### New Risks Introduced
- **PKI Root CA Compromise**: Root CA private key security becomes critical
- **Cert Manager Dependency**: Certificate issuance depends on Cert Manager availability
- **Complex Troubleshooting**: Multi-component certificate chain requires deeper expertise
- **FIPS Incompatibility**: Solution may not work in FIPS-enabled environments

## Implementation

### Phase 1: Configuration Update
```bash
# Update ClusterLogForwarder template
git add base/cluster-log-forwarder/cluster-log-forwarder-template.yaml
git commit -m "Add TLS CA bundle configuration to resolve certificate verification"
```

### Phase 2: Deployment and Validation
```bash
# Deploy updated configuration
git push origin main

# Wait for ArgoCD sync
sleep 60

# Validate TLS resolution
oc logs instance-<pod-id> -n openshift-logging --tail=20 | grep -v "certificate verify failed"
```

### Phase 3: Monitoring Setup
```bash
# Monitor log delivery success
oc get clusterlogforwarder instance -n openshift-logging -o jsonpath='{.status.conditions}'

# Check Vector metrics for successful deliveries
# (Future: Implement metrics collection)
```

### Success Criteria

#### Immediate Validation
- ✅ Vector logs show no TLS certificate verification errors
- ✅ Log delivery to Loki Gateway succeeds
- ✅ ClusterLogForwarder maintains Valid and Authorized status
- ✅ No impact on log collection from nodes

#### Long-term Monitoring
- ✅ Sustained log delivery without TLS failures
- ✅ Certificate rotation handled automatically
- ✅ No performance degradation from TLS verification
- ✅ Log data visible in Loki queries

### Rollback Procedure
If TLS configuration causes issues:
```bash
# Revert to previous configuration
git revert <commit-hash>
git push origin main

# Emergency TLS bypass (temporary only)
oc patch clusterlogforwarder instance -n openshift-logging --type='json' \
  -p='[{"op": "add", "path": "/spec/outputs/0/lokiStack/tls/insecureSkipVerify", "value": true}]'
```

## Validation Commands

### Pre-Implementation Check
```bash
# Verify CA ConfigMap exists
oc get configmap openshift-service-ca.crt -n openshift-logging

# Check current TLS errors
oc logs instance-<pod-id> -n openshift-logging | grep "certificate verify failed" | wc -l
```

### Post-Implementation Validation
```bash
# Verify no TLS errors
oc logs instance-<pod-id> -n openshift-logging --since=5m | grep "certificate verify failed" || echo "No TLS errors found"

# Check log delivery success
oc logs instance-<pod-id> -n openshift-logging --since=5m | grep "successfully sent" | wc -l
```

## Research Findings Integration

This ADR has been updated based on comprehensive research conducted on 2025-08-17. Key findings that influenced the implementation approach:

### Critical Technical Discoveries
1. **Secret Data Key Format**: ClusterLogForwarder specifically requires `ca-bundle.crt` data key, not `ca.crt` generated by Cert Manager
2. **Version Dependency**: OpenShift Logging 6.3 exclusively uses `observability.openshift.io/v1` - legacy versions are ignored
3. **Certificate Chain Requirements**: Vector requires Root CA certificate in trust bundle, not intermediate or server certificates
4. **Vector TLS Implementation**: Uses embedded OpenSSL with specific CA bundle loading mechanisms from mounted file paths
5. **GitOps Integration**: ArgoCD OutOfSync status is expected with Cert Manager due to dynamic secret updates

### Implementation Impact
- **Dedicated Secret Required**: Cannot directly reference Cert Manager generated secrets for ClusterLogForwarder
- **Root CA Extraction**: Must extract Root CA public certificate from `internal-root-ca-secret` and create dedicated secret
- **ArgoCD Configuration**: Need `ignoreDifferences` configuration to handle operator-managed resources
- **FIPS Compatibility**: Must verify cluster FIPS status as Vector does not support FIPS-enabled clusters

### Research Documentation
- **Research Questions**: [docs/research/research-questions-2025-08-17-tls-certificate-issues.md](../research/research-questions-2025-08-17-tls-certificate-issues.md)
- **Research Response**: [docs/research/research-response-2025-08-17-tls-certificate-issues.md](../research/research-response-2025-08-17-tls-certificate-issues.md)
- **Research Tracking**: [docs/research/research-tracking-dashboard.md](../research/research-tracking-dashboard.md)

## References
- [ADR-0010: Log Collection TLS Certificate Management Strategy](./adr-0010-log-collection-tls-certificate-management.md)
- [OpenShift Logging 6.3 Documentation](https://docs.openshift.com/container-platform/latest/observability/logging/cluster-logging.html)
- [Cert Manager Documentation](https://cert-manager.io/docs/)
- [Vector TLS Configuration](https://vector.dev/docs/reference/configuration/sinks/loki/#tls)
- [ArgoCD ignoreDifferences](https://argo-cd.readthedocs.io/en/stable/user-guide/diffing/#application-level-configuration)

## Related ADRs
- ADR-0010: Log Collection TLS Certificate Management Strategy
- ADR-0012: RBAC Strategy for Log Collection ServiceAccounts
- ADR-0013: Multi-Environment Log Forwarding Architecture
